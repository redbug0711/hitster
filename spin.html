<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Neon-GlÃ¼cksrad</title>
  <style>
    :root{
      --bg: #0b0e13;
      --panel: #0f1420;
      --text: #e9edf6;
      --muted: #9aa6bf;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background: radial-gradient(900px 500px at 50% 20%, #1a2440 0%, var(--bg) 55%, #070910 100%);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      padding: 18px;
    }
    .wrap{
      width:min(520px, 100%);
      background: rgba(15,20,32,.55);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
    }
    h1{
      margin: 4px 0 10px;
      font-size: 18px;
      letter-spacing: .2px;
      color: #f5f7ff;
    }
    .sub{
      margin: 0 0 14px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }
    .stage{
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 12px 8px 4px;
    }
    canvas{
      width:min(420px, 90vw);
      height:auto;
      aspect-ratio: 1 / 1;
      border-radius: 22px;
      background: transparent;
      touch-action: manipulation;
    }
    .controls{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content:center;
      padding: 12px 8px 8px;
      flex-wrap: wrap;
    }
    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.05));
      color: var(--text);
      padding: 12px 16px;
      border-radius: 14px;
      font-weight: 650;
      letter-spacing: .2px;
      cursor:pointer;
      box-shadow: 0 10px 22px rgba(0,0,0,.35);
    }
    button:active{ transform: translateY(1px); }
    button[disabled]{ opacity:.55; cursor:not-allowed; transform:none; }
    .result{
      text-align:center;
      padding: 6px 0 2px;
      font-size: 16px;
      font-weight: 700;
      min-height: 24px;
    }
    .hint{
      text-align:center;
      color: var(--muted);
      font-size: 12px;
      margin-top: 6px;
    }
    .pill{
      display:inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size: 12px;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ðŸŽ¡ Neon-GlÃ¼cksrad (wie dein Foto)</h1>
    <p class="sub">
      5 Farb-Segmente (grÃ¼n, lila, blau, rosa, gelb) im Neon-Look â€“ zufÃ¤lliger Stopp, Ergebnisanzeige.
    </p>

    <div class="stage">
      <canvas id="wheel" width="900" height="900"></canvas>
    </div>

    <div class="controls">
      <button id="spinBtn">Drehen</button>
      <span class="pill" id="status">bereit</span>
    </div>

    <div class="result" id="result"></div>
    <div class="hint">Tipp: Auf dem Handy einfach â€žDrehenâ€œ tippen.</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("wheel");
  const ctx = canvas.getContext("2d");
  const spinBtn = document.getElementById("spinBtn");
  const resultEl = document.getElementById("result");
  const statusEl = document.getElementById("status");

  // 5 Segmente wie im Wunsch (Farben)
  const segments = [
    { key:"gruen", label:"GrÃ¼n",  color:"#35d07f", glow:"#5bffb0", extra:["âœ¦","âœ¦","âœ¦"] },
    { key:"lila",  label:"Lila",  color:"#7a6cff", glow:"#a89dff", extra:["0","0","0"] },
    { key:"blau",  label:"Blau",  color:"#2f92ff", glow:"#66b6ff", extra:["2","2"] },
    { key:"rosa",  label:"Rosa",  color:"#d34cff", glow:"#ff8bff", extra:["200","200","200"] },
    { key:"gelb",  label:"Gelb",  color:"#c9c93a", glow:"#fff27a", extra:["4","4"] },
  ];

  const N = segments.length;
  const TAU = Math.PI * 2;
  const segAngle = TAU / N;

  // Pointer oben (wie Zeiger)
  const pointerAngle = -Math.PI/2;

  let currentAngle = 0;
  let spinning = false;

  // ---------- Helper: Neon drawing ----------
  function neonStroke(pathFn, stroke, width, glow, glowBlur) {
    ctx.save();
    ctx.lineWidth = width;
    ctx.strokeStyle = stroke;
    ctx.shadowColor = glow;
    ctx.shadowBlur = glowBlur;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    pathFn();
    ctx.stroke();
    ctx.restore();
  }

  function neonFill(pathFn, fill, glow, glowBlur) {
    ctx.save();
    ctx.fillStyle = fill;
    ctx.shadowColor = glow;
    ctx.shadowBlur = glowBlur;
    ctx.beginPath();
    pathFn();
    ctx.fill();
    ctx.restore();
  }

  function drawBackground(cx, cy, r) {
    // Black disc
    ctx.save();
    ctx.clearRect(0,0,canvas.width, canvas.height);

    // soft vignette
    const g = ctx.createRadialGradient(cx, cy, r*0.2, cx, cy, r*1.05);
    g.addColorStop(0, "#121a2a");
    g.addColorStop(0.55, "#070a10");
    g.addColorStop(1, "#04050a");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(cx, cy, r*1.02, 0, TAU);
    ctx.fill();

    // rim
    neonStroke(() => ctx.arc(cx, cy, r*0.98, 0, TAU), "rgba(255,255,255,.12)", r*0.015, "rgba(255,255,255,.25)", r*0.06);
    ctx.restore();
  }

  function drawCenterDome(cx, cy, r) {
    // center "dome" like the photo (grey translucent)
    ctx.save();
    const domeR = r*0.23;

    const grad = ctx.createRadialGradient(cx - domeR*0.25, cy - domeR*0.25, domeR*0.2, cx, cy, domeR);
    grad.addColorStop(0, "rgba(255,255,255,.85)");
    grad.addColorStop(0.35, "rgba(200,210,230,.55)");
    grad.addColorStop(1, "rgba(90,100,120,.25)");

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(cx, cy, domeR, 0, TAU);
    ctx.fill();

    // facets impression
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = "rgba(255,255,255,.35)";
    ctx.lineWidth = r*0.004;
    for(let i=0;i<18;i++){
      const a = (i/18)*TAU;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(a)*domeR, cy + Math.sin(a)*domeR);
      ctx.stroke();
    }

    // dome ring
    ctx.globalAlpha = 1;
    neonStroke(() => ctx.arc(cx, cy, domeR, 0, TAU), "rgba(255,255,255,.18)", r*0.01, "rgba(255,255,255,.25)", r*0.05);

    ctx.restore();
  }

  function drawPointer(cx, cy, r) {
    // top pointer triangle
    ctx.save();
    const w = r*0.08;
    const h = r*0.10;

    ctx.translate(cx, cy);
    ctx.rotate(pointerAngle);

    neonFill(() => {
      ctx.moveTo(0, -r*0.98);
      ctx.lineTo(-w/2, -r*0.98 + h);
      ctx.lineTo(w/2, -r*0.98 + h);
      ctx.closePath();
    }, "rgba(255,255,255,.9)", "rgba(255,255,255,.65)", r*0.08);

    ctx.restore();
  }

  function segmentIndexAtPointer(angle) {
    // pointer is at -90deg; we want which segment is under that pointer.
    // Convert pointer direction into wheel local angle:
    // if wheel rotates by angle, the content rotates; effective pointer samples at (-90 - angle)
    let a = (pointerAngle - angle) % TAU;
    if (a < 0) a += TAU;
    const idx = Math.floor(a / segAngle);
    return idx; // 0..N-1
  }

  function drawWheel(angle) {
    const w = canvas.width;
    const h = canvas.height;
    const cx = w/2;
    const cy = h/2;
    const r = Math.min(w,h)*0.47;

    drawBackground(cx, cy, r);

    // segments: neon spokes + squares + small neon marks like photo
    for (let i=0;i<N;i++){
      const seg = segments[i];
      const a0 = angle + i*segAngle;
      const aMid = a0 + segAngle*0.52;

      // radial neon line (spoke)
      neonStroke(() => {
        ctx.moveTo(cx + Math.cos(a0)*r*0.25, cy + Math.sin(a0)*r*0.25);
        ctx.lineTo(cx + Math.cos(a0)*r*0.95, cy + Math.sin(a0)*r*0.95);
      }, "rgba(255,255,255,.14)", r*0.01, seg.glow, r*0.07);

      // colored square near rim (like photo)
      const sqDist = r*0.67;
      const sqSize = r*0.27;
      const sx = cx + Math.cos(aMid)*sqDist;
      const sy = cy + Math.sin(aMid)*sqDist;

      ctx.save();
      ctx.translate(sx, sy);
      ctx.rotate(aMid + Math.PI/2); // make squares look "upright-ish"
      neonFill(() => {
        ctx.rect(-sqSize/2, -sqSize/2, sqSize, sqSize);
      }, "rgba(0,0,0,0)", seg.glow, r*0.09);

      // inner fill
      ctx.fillStyle = seg.color;
      ctx.globalAlpha = 0.80;
      ctx.fillRect(-sqSize/2, -sqSize/2, sqSize, sqSize);

      // border
      ctx.globalAlpha = 1;
      neonStroke(() => {
        ctx.rect(-sqSize/2, -sqSize/2, sqSize, sqSize);
      }, "rgba(255,255,255,.18)", r*0.01, seg.glow, r*0.10);

      ctx.restore();

      // extra text/markers (numbers like photo)
      // put them near outer ring on both sides
      const txtDist = r*0.86;
      const tx = cx + Math.cos(a0 + segAngle*0.15)*txtDist;
      const ty = cy + Math.sin(a0 + segAngle*0.15)*txtDist;

      ctx.save();
      ctx.translate(tx, ty);
      ctx.rotate(a0 + segAngle*0.15 + Math.PI/2);
      ctx.font = `700 ${Math.floor(r*0.08)}px system-ui, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      ctx.fillStyle = "rgba(180,190,255,.45)";
      ctx.shadowColor = seg.glow;
      ctx.shadowBlur = r*0.08;

      // choose a representative label style (like 200 / 2 / 4 / 0)
      // If segment has "extra" array, render 1-2 items stacked
      const lines = seg.extra.slice(0,2);
      if (lines.length === 1){
        ctx.fillText(lines[0], 0, 0);
      } else {
        ctx.fillText(lines[0], 0, -r*0.045);
        ctx.fillText(lines[1], 0,  r*0.045);
      }
      ctx.restore();

      // small neon corner mark (little triangle-ish)
      const markDist = r*0.90;
      const mx = cx + Math.cos(a0 + segAngle*0.82)*markDist;
      const my = cy + Math.sin(a0 + segAngle*0.82)*markDist;
      ctx.save();
      ctx.translate(mx, my);
      ctx.rotate(a0 + segAngle*0.82 + Math.PI/2);
      neonStroke(() => {
        ctx.moveTo(0,0);
        ctx.lineTo(r*0.04, r*0.06);
        ctx.lineTo(-r*0.04, r*0.06);
        ctx.closePath();
      }, "rgba(255,255,255,.16)", r*0.006, seg.glow, r*0.06);
      ctx.restore();
    }

    drawCenterDome(cx, cy, r);
    drawPointer(cx, cy, r);
  }

  function setUI(isSpinning) {
    spinBtn.disabled = isSpinning;
    statusEl.textContent = isSpinning ? "drehtâ€¦" : "bereit";
  }

  function spin() {
    if (spinning) return;
    spinning = true;
    setUI(true);
    resultEl.textContent = "";

    // ZufÃ¤lliges Zielsegment
    const targetIdx = Math.floor(Math.random() * N);

    // Wir wollen, dass der Pointer am Ende auf targetIdx zeigt.
    // DafÃ¼r setzen wir ein Ziel fÃ¼r currentAngle:
    // pointer samples (pointerAngle - angle) => should be within targetIdx segment.
    // We'll aim for the middle of the target segment.
    const targetMid = targetIdx*segAngle + segAngle*0.5;
    // We need: (pointerAngle - angle) â‰ˆ targetMid  (mod 2Ï€)
    // => angle â‰ˆ pointerAngle - targetMid (mod 2Ï€)
    let targetAngle = pointerAngle - targetMid;

    // Add several full spins for drama + small random offset within segment
    const spins = 6 + Math.floor(Math.random()*3); // 6-8
    const intra = (Math.random()*0.6 - 0.3) * segAngle; // +- 0.3 segment
    const finalAngle = targetAngle + intra + spins*TAU;

    const duration = 3200;
    const start = performance.now();
    const startAngle = currentAngle;

    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

    function anim(now){
      const t = Math.min((now - start) / duration, 1);
      const e = easeOutCubic(t);
      currentAngle = startAngle + (finalAngle - startAngle) * e;

      drawWheel(currentAngle);

      if (t < 1){
        requestAnimationFrame(anim);
      } else {
        // snap to exact final
        currentAngle = finalAngle % TAU;
        drawWheel(currentAngle);

        const idx = segmentIndexAtPointer(currentAngle);
        const seg = segments[idx];

        resultEl.textContent = `Ergebnis: ${seg.label}`;
        spinning = false;
        setUI(false);
      }
    }

    requestAnimationFrame(anim);
  }

  // init
  drawWheel(currentAngle);
  setUI(false);

  spinBtn.addEventListener("click", spin);

  // Optional: tip-to-spin on the wheel area
  canvas.addEventListener("click", () => { if(!spinning) spin(); });
})();
</script>
</body>
</html>
