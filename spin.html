<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hitser</title>
  <style>
    :root{
      --bg: #0b0e13;
      --panel: #0f1420;
      --text: #e9edf6;
      --muted: #9aa6bf;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background: radial-gradient(900px 500px at 50% 20%, #1a2440 0%, var(--bg) 55%, #070910 100%);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      padding: 18px;
    }
    .wrap{
      width:min(680px, 100%);
      background: rgba(15,20,32,.55);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
    }
    h1{
      margin: 4px 0 10px;
      font-size: 18px;
      letter-spacing: .2px;
      color: #f5f7ff;
    }
    .sub{
      margin: 0 0 14px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }
    .stage{
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 12px 8px 4px;
    }
    canvas{
      width:min(620px, 90vw);
      height:auto;
      aspect-ratio: 1 / 1;
      border-radius: 22px;
      background: transparent;
      touch-action: manipulation;
    }
    .controls{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content:center;
      padding: 12px 8px 8px;
      flex-wrap: wrap;
    }
    .status{
        display:flex;
        gap: 10px;
        align-items:center;
        justify-content:center;
        padding: 5px 8px 8px;
        flex-wrap: wrap;
    }
    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,.14);
      background: rgb(12, 236, 162);
      color: #000;
      padding: 16px 24px;
      border-radius: 2px;
      font-weight: 650;
      letter-spacing: .3px;
      cursor:pointer;
      box-shadow: 0 10px 22px rgba(0,0,0,.35);
    }
    button:active{ transform: translateY(1px); }
    button[disabled]{ opacity:.55; cursor:not-allowed; transform:none; }
    .result{
      text-align:center;
      padding: 6px 0 2px;
      font-size: 16px;
      font-weight: 700;
      min-height: 24px;
    }
    .hint{
      text-align:center;
      color: var(--muted);
      font-size: 12px;
      margin-top: 6px;
    }
    .pill{
      display:inline-block;
      padding: 4px 8px;
      border-radius: 9px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size: 12px;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <canvas id="wheel" width="900" height="900"></canvas>
    </div>

    <div class="controls">
      <button id="spinBtn">Drehen</button>
    </div>
      <div class="status">
          <span class="pill" id="status">bereit</span>
      </div>

    <div class="result" id="result"></div>
  </div>

  <script>
      (() => {
          const canvas = document.getElementById("wheel");
          const ctx = canvas.getContext("2d");
          const spinBtn = document.getElementById("spinBtn");
          const resultEl = document.getElementById("result");
          const statusEl = document.getElementById("status");

          // Reihenfolge im Uhrzeigersinn ab oben
          const segments = [
              { label:"Gruppe / Solo", color:"#35d07f", glow:"#67ffb6" },
              { label:"Jahrzehnt",     color:"#7a6cff", glow:"#b0a6ff" },
              { label:"2 Jahre",       color:"#2f92ff", glow:"#79c0ff" },
              { label:"2000",          color:"#d34cff", glow:"#ff97ff" },
              { label:"4 Jahre",       color:"#c9c93a", glow:"#fff07a" },
          ];

          const N = segments.length;
          const TAU = Math.PI * 2;
          const segAngle = TAU / N;

          const pointerAngle = -Math.PI/2;
          const offset = pointerAngle - segAngle/2;

          let currentAngle = 0;
          let spinning = false;

          function neonStroke(pathFn, stroke, width, glow, blur) {
              ctx.save();
              ctx.lineWidth = width;
              ctx.strokeStyle = stroke;
              ctx.shadowColor = glow;
              ctx.shadowBlur = blur;
              ctx.beginPath();
              pathFn();
              ctx.stroke();
              ctx.restore();
          }

          function drawPointer(cx, cy, r) {
              ctx.save();
              // Glow
              ctx.shadowColor = "white";
              ctx.shadowBlur = r * 0.01;
              ctx.fillStyle = "white";
              ctx.beginPath();
              // Spitze (zeigt ins Rad)
              ctx.moveTo(cx, cy - r * 0.95);
              // Linke Ecke (außen oberhalb)
              ctx.lineTo(cx - r * 0.03, cy - r * 1.02);
              // Rechte Ecke (außen oberhalb)
              ctx.lineTo(cx + r * 0.03, cy - r * 1.02);
              ctx.closePath();
              ctx.fill();
              ctx.restore();
          }

          function segmentIndexAtPointer(angle) {
              let local = (pointerAngle - (angle + offset)) % TAU;
              if (local < 0) local += TAU;
              return Math.floor(local / segAngle);
          }

          function drawWheel(angle) {
              const w = canvas.width;
              const h = canvas.height;
              const cx = w/2;
              const cy = h/2;
              const r = Math.min(w,h)*0.47;

              ctx.clearRect(0,0,w,h);

              // Schwarzer Body
              ctx.fillStyle="#0b0e13";
              ctx.beginPath();
              ctx.arc(cx,cy,r,0,TAU);
              ctx.fill();

              // Außenring Neon
              neonStroke(
                  () => ctx.arc(cx,cy,r*0.99,0,TAU),
                  "rgba(255,255,255,.15)",
                  r*0.015,
                  "rgba(255,255,255,.4)",
                  r*0.1
              );

              const base = angle + offset;

              for(let i=0;i<N;i++){
                  const seg = segments[i];
                  const a0 = base + i*segAngle;
                  const aMid = a0 + segAngle/2;

                  // Trennlinie Neon
                  neonStroke(
                      () => {
                          ctx.moveTo(cx + Math.cos(a0)*r*0.25, cy + Math.sin(a0)*r*0.25);
                          ctx.lineTo(cx + Math.cos(a0)*r*0.98, cy + Math.sin(a0)*r*0.98);
                      },
                      "rgba(255,255,255,.1)",
                      r*0.01,
                      seg.glow,
                      r*0.12
                  );

                  // Farbiges Quadrat
                  const sqDist = r*0.68;
                  const sqSize = r*0.28;
                  const sx = cx + Math.cos(aMid)*sqDist;
                  const sy = cy + Math.sin(aMid)*sqDist;

                  ctx.save();
                  ctx.translate(sx,sy);
                  ctx.rotate(aMid + Math.PI/2);

                  ctx.shadowColor = seg.glow;
                  ctx.shadowBlur = r*0.01;
                  ctx.fillStyle = seg.color;
                  ctx.fillRect(-sqSize/2,-sqSize/2,sqSize,sqSize);

                  ctx.lineWidth = r*0.01;
                  ctx.strokeStyle="rgba(255,255,255,.9)";
                  ctx.strokeRect(-sqSize/2,-sqSize/2,sqSize,sqSize);
                  ctx.restore();

                  // Beschriftung UNTERHALB des Farbfeldes
                  const textDist = r*0.46;
                  const tx = cx + Math.cos(aMid)*textDist;
                  const ty = cy + Math.sin(aMid)*textDist;

                  ctx.save();
                  ctx.translate(tx,ty);
                  ctx.rotate(aMid + Math.PI/2);
                  ctx.textAlign="center";
                  ctx.textBaseline="middle";
                  ctx.font=`bold ${Math.floor(r*0.07)}px sans-serif`;
                  ctx.fillStyle="rgba(200,210,255,.7)";
                  ctx.shadowColor=seg.glow;
                  ctx.shadowBlur=r*0.1;
                  ctx.fillText(seg.label,0,0);
                  ctx.restore();
              }

              // Mittelkuppel
              // ----- MITTELKUPPEL (bleibt fix) -----
              drawCenterDome(cx, cy, r);

              // ----- PFEIL (bleibt fix) -----
              drawPointer(cx,cy,r);
          }
          function drawCenterDome(cx, cy, r) {

              const domeR = r * 0.23;

              ctx.save();

              // --- Schatten außen ---
              ctx.shadowColor = "rgba(0,0,0,0.6)";
              ctx.shadowBlur = r * 0.04;

              // --- Hauptkuppel Verlauf ---
              const grad = ctx.createRadialGradient(
                  cx, cy, domeR * 0.1,
                  cx, cy, domeR
              );

              grad.addColorStop(0, "rgba(255,255,255,0.95)");
              grad.addColorStop(0.4, "rgba(220,235,255,0.85)");
              grad.addColorStop(0.8, "rgba(180,200,230,0.6)");
              grad.addColorStop(1, "rgba(140,160,190,0.45)");

              ctx.beginPath();
              ctx.arc(cx, cy, domeR, 0, Math.PI * 2);
              ctx.fillStyle = grad;
              ctx.fill();

              ctx.restore();


              // --- Facetten Effekt ---
              ctx.save();
              ctx.globalAlpha = 0.15;
              ctx.strokeStyle = "#ffffff";
              ctx.lineWidth = 1;

              const facets = 24;

              for (let i = 0; i < facets; i++) {
                  const angle = (i / facets) * Math.PI * 2;

                  ctx.beginPath();
                  ctx.moveTo(cx, cy);
                  ctx.lineTo(
                      cx + Math.cos(angle) * domeR,
                      cy + Math.sin(angle) * domeR
                  );
                  ctx.stroke();
              }

              ctx.restore();


              // --- Glanzreflex ---
              ctx.save();

              const shine = ctx.createRadialGradient(
                  cx - domeR * 0.3,
                  cy - domeR * 0.3,
                  0,
                  cx - domeR * 0.3,
                  cy - domeR * 0.3,
                  domeR * 0.8
              );

              shine.addColorStop(0, "rgba(255,255,255,0.8)");
              shine.addColorStop(1, "rgba(255,255,255,0)");

              ctx.beginPath();
              ctx.arc(cx, cy, domeR, 0, Math.PI * 2);
              ctx.fillStyle = shine;
              ctx.fill();

              ctx.restore();


              // --- Dunkler Außenring ---
              ctx.save();
              ctx.lineWidth = r * 0.015;
              ctx.strokeStyle = "rgba(0,0,0,0.6)";
              ctx.beginPath();
              ctx.arc(cx, cy, domeR, 0, Math.PI * 2);
              ctx.stroke();
              ctx.restore();
          }


          function spin(){
              if(spinning) return;
              spinning=true;
              spinBtn.disabled=true;
              statusEl.textContent="dreht…";
              resultEl.textContent="";

              const targetIdx=Math.floor(Math.random()*N);
              const targetMid=targetIdx*segAngle+segAngle/2;
              let targetAngle=pointerAngle-offset-targetMid;

              const spins=7;
              const intra=(Math.random()*0.6-0.3)*segAngle;
              const finalAngle=targetAngle+intra+spins*TAU;

              const duration=6200;
              const start=performance.now();
              const startAngle=currentAngle;

              function ease(t){return 1-Math.pow(1-t,3);}

              function animate(now){
                  const t=Math.min((now-start)/duration,1);
                  currentAngle=startAngle+(finalAngle-startAngle)*ease(t);
                  drawWheel(currentAngle);

                  if(t<1){
                      requestAnimationFrame(animate);
                  }else{
                      currentAngle=finalAngle%TAU;
                      drawWheel(currentAngle);
                      const idx=segmentIndexAtPointer(currentAngle);
                      resultEl.textContent="Kategorie: "+segments[idx].label;
                      spinning=false;
                      spinBtn.disabled=false;
                      statusEl.textContent="bereit";
                  }
              }
              requestAnimationFrame(animate);
          }

          drawWheel(currentAngle);
          spinBtn.addEventListener("click",spin);
      })();
  </script>


</body>
</html>
